/***
Copyright 2014 Cisco Systems Inc. All rights reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"bytes"
	"errors"
	"fmt"
	"text/template"

	log "github.com/Sirupsen/logrus"
)

// GenerateGo generates go code for the schema
func (s *Schema) GenerateGo() (string, error) {
	// Generate file headers
	outStr := s.GenerateGoHdrs()

	// Generate structs
	structStr, err := s.GenerateGoStructs()
	if err != nil {
		log.Errorf("Error generating go structs. Err: %v", err)
		return "", err
	}

	// Merge the header and struct
	outStr = outStr + structStr

	// Merge rest handler
	outStr = outStr + s.GenerateGoFuncs()

	return outStr, nil
}

// GenerateGoStructs generates go code from a schema
func (s *Schema) GenerateGoStructs() (string, error) {
	var goStr string

	//  Generate all object definitions
	for _, obj := range s.Objects {
		objStr, err := obj.GenerateGoStructs()
		if err == nil {
			goStr = goStr + objStr
		}
	}

	// Generate a collection definitions to store the objects
	goStr = goStr + fmt.Sprintf("\n\ntype Collections struct {\n")
	for _, obj := range s.Objects {
		goStr = goStr + fmt.Sprintf("	%ss    map[string]*%s\n", obj.Name, initialCap(obj.Name))
	}
	goStr = goStr + fmt.Sprintf("}\n\n")

	goStr = goStr + fmt.Sprintf("var collections Collections\n\n")

	// Generate callback interface
	for _, obj := range s.Objects {
		goStr = goStr + fmt.Sprintf("type %sCallbacks interface {\n", initialCap(obj.Name))
		goStr = goStr + fmt.Sprintf("	%sCreate(%s *%s) error\n", initialCap(obj.Name), obj.Name, initialCap(obj.Name))
		goStr = goStr + fmt.Sprintf("	%sUpdate(%s, params *%s) error\n", initialCap(obj.Name), obj.Name, initialCap(obj.Name))
		goStr = goStr + fmt.Sprintf("	%sDelete(%s *%s) error\n", initialCap(obj.Name), obj.Name, initialCap(obj.Name))
		goStr = goStr + fmt.Sprintf("}\n\n")
	}

	// generate callback handler
	goStr = goStr + fmt.Sprintf("type CallbackHandlers struct {\n")
	for _, obj := range s.Objects {
		goStr = goStr + fmt.Sprintf("	%sCb %sCallbacks\n", initialCap(obj.Name), initialCap(obj.Name))
	}
	goStr = goStr + fmt.Sprintf("}\n\n")

	goStr = goStr + fmt.Sprintf("var objCallbackHandler CallbackHandlers\n\n")

	// Generate an Init function
	goStr = goStr + fmt.Sprintf("\nfunc Init() {\n")
	for _, obj := range s.Objects {
		goStr = goStr + fmt.Sprintf("	collections.%ss = make(map[string]*%s)\n", obj.Name, initialCap(obj.Name))
	}
	goStr = goStr + fmt.Sprintf("\n")
	for _, obj := range s.Objects {
		goStr = goStr + fmt.Sprintf("	restore%s()\n", initialCap(obj.Name))
	}

	goStr = goStr + fmt.Sprintf("}\n\n")

	// Generate callback register functions
	for _, obj := range s.Objects {
		goStr = goStr + fmt.Sprintf("func Register%sCallbacks(handler %sCallbacks) {\n", initialCap(obj.Name), initialCap(obj.Name))
		goStr = goStr + fmt.Sprintf("	objCallbackHandler.%sCb = handler\n", initialCap(obj.Name))
		goStr = goStr + fmt.Sprintf("}\n\n")
	}
	return goStr, nil
}

// GenerateGoHdrs generates go file headers
func (s *Schema) GenerateGoHdrs() string {
	var buf bytes.Buffer

	const hdr = `// {{.Name}}.go
// This file is auto generated by modelgen tool
// Do not edit this file manually

package {{.Name}}

import (
	"errors"
	"regexp"
	"net/http"
	"encoding/json"
	"github.com/contiv/objmodel/objdb/modeldb"
	"github.com/gorilla/mux"
	log "github.com/Sirupsen/logrus"
)

type HttpApiFunc func(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error)

`

	tmpl := template.Must(template.New("hdr").Parse(hdr))
	err := tmpl.Execute(&buf, s)
	if err != nil {
		log.Errorf("Error executing template. Err: %v", err)
		return ""
	}

	return buf.String()
}

func (s *Schema) GenerateGoFuncs() string {
	var buf bytes.Buffer
	var goStr string

	routeFunc := `
// Simple Wrapper for http handlers
func makeHttpHandler(handlerFunc HttpApiFunc) http.HandlerFunc {
	// Create a closure and return an anonymous function
	return func(w http.ResponseWriter, r *http.Request) {
		// Call the handler
		resp, err := handlerFunc(w, r, mux.Vars(r))
		if err != nil {
			// Log error
			log.Errorf("Handler for %s %s returned error: %s", r.Method, r.URL, err)

			// Send HTTP response
			http.Error(w, err.Error(), http.StatusInternalServerError)
		} else {
			// Send HTTP response as Json
			err = writeJSON(w, http.StatusOK, resp)
			if err != nil {
				log.Errorf("Error generating json. Err: %v", err)
			}
		}
	}
}

// writeJSON: writes the value v to the http response stream as json with standard
// json encoding.
func writeJSON(w http.ResponseWriter, code int, v interface{}) error {
	// Set content type as json
	w.Header().Set("Content-Type", "application/json")

	// write the HTTP status code
	w.WriteHeader(code)

	// Write the Json output
	return json.NewEncoder(w).Encode(v)
}

// Add all routes for REST handlers
func AddRoutes(router *mux.Router) {
	var route, listRoute string
`
	funcMap := template.FuncMap{
		"initialCap": initialCap,
	}
	routeTmpl := `
	// Register {{.}}
	route = "/api/{{.}}s/{key}/"
	listRoute = "/api/{{.}}s/"
	log.Infof("Registering %s", route)
	router.Path(listRoute).Methods("GET").HandlerFunc(makeHttpHandler(httpList{{initialCap .}}s))
	router.Path(route).Methods("GET").HandlerFunc(makeHttpHandler(httpGet{{initialCap .}}))
	router.Path(route).Methods("POST").HandlerFunc(makeHttpHandler(httpCreate{{initialCap .}}))
	router.Path(route).Methods("PUT").HandlerFunc(makeHttpHandler(httpCreate{{initialCap .}}))
	router.Path(route).Methods("DELETE").HandlerFunc(makeHttpHandler(httpDelete{{initialCap .}}))
`
	// Output the functions and routes
	rfTmpl, _ := template.New("routeFunc").Parse(routeFunc)
	rfTmpl.Execute(&buf, "")
	goStr = goStr + buf.String()

	// add a path for each object
	for _, obj := range s.Objects {
		var buf bytes.Buffer

		// Create a template, add the function map, and parse the text.
		tmpl, err := template.New("routeTmpl").Funcs(funcMap).Parse(routeTmpl)
		if err != nil {
			log.Fatalf("parsing: %s", err)
		}

		// Run the template.
		err = tmpl.Execute(&buf, obj.Name)
		if err != nil {
			log.Fatalf("execution: %s", err)
		}

		goStr = goStr + buf.String()
	}

	goStr = goStr + fmt.Sprintf("\n}\n")

	// template for handler functions
	handlerFuncs := `
// LIST REST call
func httpList{{initialCap .}}s(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpList{{initialCap .}}s: %+v", vars)

	list := make([]*{{initialCap .}}, 0)
	for _, obj := range collections.{{.}}s {
		list = append(list, obj)
	}

	// Return the list
	return list, nil
}

// GET REST call
func httpGet{{initialCap .}}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGet{{initialCap .}}: %+v", vars)

	key := vars["key"]

	obj := collections.{{.}}s[key]
	if obj == nil {
		log.Errorf("{{.}} %s not found", key)
		return nil, errors.New("{{.}} not found")
	}

	// Return the obj
	return obj, nil
}

// CREATE REST call
func httpCreate{{initialCap .}}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpGet{{initialCap .}}: %+v", vars)

	var obj {{initialCap .}}
	key := vars["key"]

	// Get object from the request
	err := json.NewDecoder(r.Body).Decode(&obj)
	if err != nil {
		log.Errorf("Error decoding {{.}} create request. Err %v", err)
		return nil, err
	}

	// set the key
	obj.Key = key

	// Create the object
	err = Create{{initialCap .}}(&obj)
	if err != nil {
		log.Errorf("Create{{initialCap .}} error for: %+v. Err: %v", obj, err)
		return nil, err
	}

	// Return the obj
	return obj, nil
}

// DELETE rest call
func httpDelete{{initialCap .}}(w http.ResponseWriter, r *http.Request, vars map[string]string) (interface{}, error) {
	log.Debugf("Received httpDelete{{initialCap .}}: %+v", vars)

	key := vars["key"]

	// Delete the object
	err := Delete{{initialCap .}}(key)
	if err != nil {
		log.Errorf("Delete{{initialCap .}} error for: %s. Err: %v", key, err)
		return nil, err
	}

	// Return the obj
	return key, nil
}

// Create a {{.}} object
func Create{{initialCap .}}(obj *{{initialCap .}}) error {
	// Validate parameters
	err := Validate{{initialCap .}}(obj)
	if err != nil {
		log.Errorf("Validate{{initialCap .}} retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// Check if we handle this object
	if objCallbackHandler.{{initialCap .}}Cb == nil {
		log.Errorf("No callback registered for {{.}} object")
		return errors.New("Invalid object type")
	}

	// Check if object already exists
	if collections.{{.}}s[obj.Key] != nil {
		// Perform Update callback
		err = objCallbackHandler.{{initialCap .}}Cb.{{initialCap .}}Update(collections.{{.}}s[obj.Key], obj)
		if err != nil {
			log.Errorf("{{initialCap .}}Update retruned error for: %+v. Err: %v", obj, err)
			return err
		}
	} else {
		// save it in cache
		collections.{{.}}s[obj.Key] = obj

		// Perform Create callback
		err = objCallbackHandler.{{initialCap .}}Cb.{{initialCap .}}Create(obj)
		if err != nil {
			log.Errorf("{{initialCap .}}Create retruned error for: %+v. Err: %v", obj, err)
			delete(collections.{{.}}s, obj.Key)
			return err
		}
	}

	// Write it to modeldb
	err = obj.Write()
	if err != nil {
		log.Errorf("Error saving {{.}} %s to db. Err: %v", obj.Key, err)
		return err
	}

	return nil
}

// Return a pointer to {{.}} from collection
func Find{{initialCap .}}(key string) *{{initialCap .}} {
	obj := collections.{{.}}s[key]
	if obj == nil {
		log.Errorf("{{.}} %s not found", key)
		return nil
	}

	return obj
}

// Delete a {{.}} object
func Delete{{initialCap .}}(key string) error {
	obj := collections.{{.}}s[key]
	if obj == nil {
		log.Errorf("{{.}} %s not found", key)
		return errors.New("{{.}} not found")
	}

	// Check if we handle this object
	if objCallbackHandler.{{initialCap .}}Cb == nil {
		log.Errorf("No callback registered for {{.}} object")
		return errors.New("Invalid object type")
	}

	// Perform callback
	err := objCallbackHandler.{{initialCap .}}Cb.{{initialCap .}}Delete(obj)
	if err != nil {
		log.Errorf("{{initialCap .}}Delete retruned error for: %+v. Err: %v", obj, err)
		return err
	}

	// delete it from modeldb
	err = obj.Delete()
	if err != nil {
		log.Errorf("Error deleting {{.}} %s. Err: %v", obj.Key, err)
	}

	// delete it from cache
	delete(collections.{{.}}s, key)

	return nil
}

func (self *{{initialCap .}}) GetType() string {
	return "{{.}}"
}

func (self *{{initialCap .}}) GetKey() string {
	return self.Key
}

func (self *{{initialCap .}}) Read() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to read {{.}} object")
		return errors.New("Empty key")
	}

	return modeldb.ReadObj("{{.}}", self.Key, self)
}

func (self *{{initialCap .}}) Write() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Write {{.}} object")
		return errors.New("Empty key")
	}

	return modeldb.WriteObj("{{.}}", self.Key, self)
}

func (self *{{initialCap .}}) Delete() error {
	if self.Key == "" {
		log.Errorf("Empty key while trying to Delete {{.}} object")
		return errors.New("Empty key")
	}

	return modeldb.DeleteObj("{{.}}", self.Key)
}

func restore{{initialCap .}}() error {
	strList, err := modeldb.ReadAllObj("{{.}}")
	if err != nil {
		log.Errorf("Error reading {{.}} list. Err: %v", err)
	}

	for _, objStr := range strList {
		// Parse the json model
		var {{.}} {{initialCap .}}
		err = json.Unmarshal([]byte(objStr), &{{.}})
		if err != nil {
			log.Errorf("Error parsing object %s, Err %v", objStr, err)
			return err
		}

		// add it to the collection
		collections.{{.}}s[{{.}}.Key] = &{{.}}
	}

	return nil
}
`
	// Generate REST handlers for each object
	for _, obj := range s.Objects {
		var buf bytes.Buffer
		// Create a template, add the function map, and parse the text.
		tmpl, err := template.New("handlerFuncs").Funcs(funcMap).Parse(handlerFuncs)
		if err != nil {
			log.Fatalf("parsing: %s", err)
		}

		// Run the template.
		err = tmpl.Execute(&buf, obj.Name)
		if err != nil {
			log.Fatalf("execution: %s", err)
		}

		goStr = goStr + buf.String()

		//  Generate object validators
		objStr, err := obj.GenerateValidate()
		if err == nil {
			goStr = goStr + objStr
		}
	}

	return goStr
}

func (obj *Object) GenerateGoStructs() (string, error) {
	var goStr string

	objName := initialCap(obj.Name)
	goStr = goStr + fmt.Sprintf("type %s struct {\n", objName)

	// every object has a key
	goStr = goStr + fmt.Sprintf("	Key		string		`json:\"key,omitempty\"`\n")

	// Walk each property and generate code for it
	for _, prop := range obj.Properties {
		propStr, err := prop.GenerateGoStructs()
		if err == nil {
			goStr = goStr + propStr
		}
	}

	// add link-sets
	if len(obj.LinkSets) > 0 {
		goStr = goStr + fmt.Sprintf("	LinkSets	%sLinkSets		`json:\"link-sets,omitempty\"`\n", objName)
	}

	// add links
	if len(obj.Links) > 0 {
		goStr = goStr + fmt.Sprintf("	Links	%sLinks		`json:\"links,omitempty\"`\n", objName)
	}

	goStr = goStr + fmt.Sprintf("}\n\n")

	// define object's linkset
	if len(obj.LinkSets) > 0 {
		goStr = goStr + fmt.Sprintf("type %sLinkSets struct {\n", objName)
		for lsName := range obj.LinkSets {
			goStr = goStr + fmt.Sprintf("	%s	map[string]modeldb.Link		`json:\"%s,omitempty\"`\n", initialCap(lsName), lsName)
		}
		goStr = goStr + fmt.Sprintf("}\n\n")
	}

	// Define object's links
	if len(obj.Links) > 0 {
		goStr = goStr + fmt.Sprintf("type %sLinks struct {\n", objName)
		for lName := range obj.Links {
			goStr = goStr + fmt.Sprintf("	%s	modeldb.Link		`json:\"%s,omitempty\"`\n", initialCap(lName), lName)
		}
		goStr = goStr + fmt.Sprintf("}\n\n")
	}

	return goStr, nil
}

func (obj *Object) GenerateValidate() (string, error) {
	var goStr string

	funcMap := template.FuncMap{
		"initialCap": initialCap,
	}

	validateFunc := `
// Validate a {{.Name}} object
func Validate{{initialCap .Name}}(obj *{{initialCap .Name}}) error {
	// Validate key is correct
	keyStr := {{range $index, $element := .Key}}{{if eq 0 $index }}obj.{{initialCap .}} {{else}}+ ":" + obj.{{initialCap .}} {{end}}{{end}}
	if obj.Key != keyStr {
		log.Errorf("Expecting {{initialCap .Name}} Key: %s. Got: %s", keyStr, obj.Key)
		return errors.New("Invalid Key")
	}

	// Validate each field
	{{range $element := .Properties}}{{if eq $element.Type "int"}}{{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == 0 {
		obj.{{initialCap $element.Name}} = {{$element.Default}}
	}
{{end}} {{if ne $element.Min 0.0}}
	if obj.{{initialCap $element.Name}} < {{$element.Min}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{if ne $element.Max 0.0}}
	if obj.{{initialCap $element.Name}} > {{$element.Max}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{else if eq $element.Type "number"}} {{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == 0 {
		obj.{{$element.Name}} = {{$element.Default}}
	}
{{end}} {{if ne $element.Min 0.0}}
	if obj.{{initialCap $element.Name}} < {{$element.Min}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{if ne $element.Max 0.0}}
	if obj.{{initialCap $element.Name}} > {{$element.Max}} {
		return errors.New("{{$element.Name}} Value Out of bound")
	}
{{end}} {{else if eq $element.Type "bool"}} {{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == false {
		obj.{{initialCap $element.Name}} = {{$element.Default}}
	}
{{end}} {{else if eq $element.Type "string"}} {{if ne $element.Default ""}}
	if obj.{{initialCap $element.Name}} == "" {
		obj.{{initialCap $element.Name}} = {{$element.Default}}
	}
{{end}} {{if ne $element.Length 0}}
	if len(obj.{{initialCap $element.Name}}) > {{$element.Length}} {
		return errors.New("{{$element.Name}} string too long")
	}
{{end}} {{if ne $element.Format ""}}
	{{$element.Name}}Match := regexp.MustCompile("{{$element.Format}}")
	if {{$element.Name}}Match.MatchString(obj.{{initialCap $element.Name}}) == false {
		return errors.New("{{$element.Name}} string invalid format")
	}
{{end}} {{end}} {{end}}

	return nil
}
`

	var buf bytes.Buffer
	// Create a template, add the function map, and parse the text.
	tmpl, err := template.New("validateFunc").Funcs(funcMap).Parse(validateFunc)
	if err != nil {
		log.Fatalf("parsing: %s", err)
	}

	// Run the template.
	err = tmpl.Execute(&buf, obj)
	if err != nil {
		log.Fatalf("execution: %s", err)
	}

	goStr = goStr + buf.String()

	return goStr, nil
}

func xlatePropType(propType string) string {
	var goStr string
	switch propType {
	case "string":
		goStr = goStr + fmt.Sprintf("string")
	case "number":
		goStr = goStr + fmt.Sprintf("float64")
	case "int":
		goStr = goStr + fmt.Sprintf("int64")
	case "bool":
		goStr = goStr + fmt.Sprintf("bool")
	default:
		return ""
	}

	return goStr
}

func (prop *Property) GenerateGoStructs() (string, error) {
	var goStr string

	goStr = fmt.Sprintf("	%s	", initialCap(prop.Name))
	switch prop.Type {
	case "string":
		fallthrough
	case "number":
		fallthrough
	case "int":
		fallthrough
	case "bool":
		subStr := xlatePropType(prop.Type)
		goStr = goStr + fmt.Sprintf("%s		`json:\"%s,omitempty\"`\n", subStr, prop.Name)
	case "array":
		subStr := xlatePropType(prop.Items)
		if subStr == "" {
			return "", errors.New("Unknown array items")
		}

		goStr = goStr + fmt.Sprintf("[]%s		`json:\"%s,omitempty\"`\n", subStr, prop.Name)
	default:
		return "", errors.New("Unknown Property")
	}

	return goStr, nil
}
